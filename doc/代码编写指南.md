# 代码编写指南

- [代码编写指南](#代码编写指南)
  - [简介](#简介)
  - [1 支持类文件简介](#1-支持类文件简介)
    - [1.7 USER\_LIB简介](#17-user_lib简介)
    - [1.8 Controller简介](#18-controller简介)
  - [2 各个模块的使用](#2-各个模块的使用)
    - [2.1 电机的使用](#21-电机的使用)
    - [2.2 IMU的使用](#22-imu的使用)
    - [2.3 信号发生器的使用](#23-信号发生器的使用)
    - [2.4 数据交换中心的使用](#24-数据交换中心的使用)
    - [2.5 上位机调试的使用](#25-上位机调试的使用)
    - [2.6 板间通信的使用](#26-板间通信的使用)
  - [3 算法与数据结构](#3-算法与数据结构)
  - [4 操作系统](#4-操作系统)

## 简介

## 1 支持类文件简介

### 1.7 USER_LIB简介

针对编写代码时大量重复用到的算法进行抽象得到了[user_lib.c/h](../components/algorithm/user_lib.c)。如果在编写过程中想进行一些特别的计算，先别着急定义一个新函数，先到 user_lib 中看看有没有适合的相同功能的函数，直接调用更方便呦。

- [`abs_limit`](../components/algorithm/user_lib.c#L87) 绝对值限制，将数据的值限制在[-Limit~Limit]
  - 参数：
    - `[out] num (float*)` 被限制数据的地址
    - `[in] Limit (float)` 限制值
  - 返回：`无`

- [`sign`](../components/algorithm/user_lib.c#L97) 判断浮点数符号位
  - 参数：
    - `[in] value (float)` 待判断数据
  - 返回：`(float)` 数据符号，正数为1.0，复数为-1.0

- [`fp32_deadline`](../components/algorithm/user_lib.c#L107) 浮点死区
  - 参数：
    - `[in] value (float)` 被限制浮点数
    - `[in] minValue (float)` 死区下限
    - `[in] maxValue (float)` 死区上限
  - 返回：`(float)` 在死区内为0，其余为原值

- [`int16_deadline`](../components/algorithm/user_lib.c#L116) 浮点死区
  - 参数：
    - `[in] value (int16_t)` 被限制16位整型数
    - `[in] minValue (int16_t)` 死区下限
    - `[in] maxValue (int16_t)` 死区上限
  - 返回：`(int16_t)` 在死区内为0，其余为原值

- [`fp32_constrain`](../components/algorithm/user_lib.c#L125) 32位浮点数限幅函数
  - 参数：
    - `[in] value (float)` 被限幅数
    - `[in] minValue (float)` 下限
    - `[in] maxValue (float)` 上限
  - 返回：`(float)` 限幅后的数据

- [`int16_constrain`](../components/algorithm/user_lib.c#L136) 16位整数限幅函数
  - 参数：
    - `[in] value (int16_t)` 被限幅数
    - `[in] minValue (int16_t)` 下限
    - `[in] maxValue (int16_t)` 上限
  - 返回：`(int16_t)` 限幅后的数据

- [`loop_fp32_constrain`](../components/algorithm/user_lib.c#L146) 32位浮点数循环限幅函数
  - 参数：
    - `[in] value (float)` 被限幅数
    - `[in] minValue (float)` 下限
    - `[in] maxValue (float)` 上限
  - 返回：`(float)` 循环限幅后的数据

- [`theta_format`](../components/algorithm/user_lib.c#L168) 弧度格式化为-PI~PI
  - 参数：
    - `[in] Ang (float)` 输入角度
  - 返回：`(float)` 格式化后的数据

- [`theta_transform`](../components/algorithm/user_lib.c#L178) 角度在极坐标系中的转换
  - 参数：
    - `[in] angle (float)` (rad)当前角度
    - `[in] dangle (float)` (rad)旋转角度
    - `[in] direction (int8_t)` 方向，1为正，-1为负
    - `[in] duration (int8_t)` 周期（1个周期-PI~PI, 2个周期-2*PI~2*PI, ...）
  - 返回：`(float)` 转换后的角度

- [`float_to_uint`](../components/algorithm/user_lib.c#L194) 浮点数转换为无符号整数函数
  - 参数：
    - `[in] x_float (float)` 待转换的浮点数
    - `[in] x_min (float)` 范围最小值
    - `[in] x_max (float)` 范围最大值
    - `[in] bits (int)` 目标无符号整数的位数
  - 返回：`(int)` 无符号整数结果
  - 备注：将给定的浮点数 x 在指定范围 [x_min, x_max] 内进行线性映射，映射结果为一个指定位数的无符号整数

- [`uint_to_float`](../components/algorithm/user_lib.c#L212) 无符号整数转换为浮点数函数
  - 参数：
    - `[in] x_int (int)` 待转换的无符号整数
    - `[in] x_min (float)` 范围最小值
    - `[in] x_max (float)` 范围最大值
    - `[in] bits (int)` 无符号整数的位数
  - 返回：`(float)` 浮点数结果
  - 备注：将给定的无符号整数 x_int 在指定范围 [x_min, x_max] 内进行线性映射，映射结果为一个浮点数

- [`LowPassFilterInit`](../components/algorithm/user_lib.c#L225) 低通滤波器初始化
  - 参数：
    - `[in] filter (LowPassFilter_t*)` 滤波器结构体指针
    - `[in] alpha (float)` 平滑系数 $[0,1]$
  - 返回：`无`

- [`LowPassFilterCalc`](../components/algorithm/user_lib.c#L237) 低通滤波计算
  - 参数：
    - `[in] filter (LowPassFilter_t*)` 滤波器结构体指针
    - `[in] input (float)` 输入
  - 返回：`float` 滤波后的结果

### 1.8 Controller简介

在 `components/controller`文件夹中包含了一些控制算法：

- [pid控制器](../components/controller/pid.c)

## 2 各个模块的使用

### 2.1 电机的使用

相关文件: [motor.c/h](../application/robot_cmd/motor.c) , [CAN_communication.h](../application/robot_cmd/CAN_communication.h)

- **简介：**
- **创建电机对象：** [（motor.c/h）](../application/robot_cmd/motor.c) 使用`Motor_s`结构体定义电机对象

    ``` C
    #include "motor.h"
    Motor_s yaw_motor;
    ```

- **初始化：** [（motor.c/h）](../application/robot_cmd/motor.c) 使用 `MotorInit`函数完成电机对象的初始化

    ``` C
    #include "motor.h"
    MotorInit(&CHASSIS.joint_motor[3], 4, JOINT_CAN, DM_8009, J3_DIRECTION, 1, DM_MODE_MIT);
    ```

- **获取反馈数据：** [（CAN_receive.h）](../application/robot_cmd/CAN_receive.h)使用 `GetMotorMeasure`函数获取电机的状态和测量值。

    ``` C
    #include "CAN_receive.h"
    GetMotorMeasure(&CHASSIS.joint_motor[0]);
    ```

- **设置控制量：** 将电机对象的`set`属性中的对应控制量设置为需要发送的控制量
- **发送控制量：** 对不同的电机使用不同的发送函数。如：

    ``` C
    #include "CAN_communication.h"
    CanCmdDjiMotor(1, DJI_3508_MODE_CURRENT_1, 100, 100, 100, 100);
    DmMitCtrlTorque(&CHASSIS.joint_motor[0]);
    ...
    ```

    具体需要使用什么电机的函数请至 [CAN_communication.h](../application/robot_cmd/CAN_communication.h) 中查阅

### 2.2 IMU的使用

- **简介：**
- **定义IMU对象：** 使用 `Imu_t` 结构体定义IMU对象

    ``` C
    #include "data_exchange.h"
    Imu_t * IMU;
    ```

- **获取数据指针：** 使用`Subscribe`函数订阅IMU数据指针

    ``` C
    #include "data_exchange.h"
    CHASSIS.imu = Subscribe("imu_data");
    ```

### 2.3 信号发生器的使用

- **简介：** 在[signal_generator.h](../components/support/signal_generator.h)中提供了以下信号发生函数：
  - `GenerateSinWave` 用于生成正弦信号
  - `GenerateStepWave` 用于生成阶跃信号
  - `GenerateRampWave` 用于生成斜坡波信号
  - `GeneratePulseWave` 用于生成脉冲波形信号
  - `GenerateSawtoothWave` 用于生成锯齿波形信号
- **生成信号：** 调用对应的信号发生器，填入参数即可

### 2.4 数据交换中心的使用

- **简介：** 为了方便各个模块之间交换数据，减小耦合程度，使用数据交换中心来进行数据交换。在[data_exchange.h](../application/assist/data_exchange.h)中提供了`Publish`和`Subscribe`函数用来发布和订阅数据。

### 2.5 上位机调试的使用

- **简介：** 为了方便调参，查看数据动态波形，配合上位机使用。在[usb_debug.h](../application//communication//usb_debug.h)中提供了`ModifyDebugDataPackage`函数用来编辑发送给配套调试软件的debug数据包。
- **注：** 下位机需1.4.0及以上版本。上位机需3.0.0及以上版本。才可使用本功能。

### 2.6 板间通信的使用

## 3 算法与数据结构

本框架提供了一些常用的算法与数据结构：

- [list](../components/support/clist.c) 链表，数据域采用指针存放地址，可以实现对任意数据类型的存放。
- [fifo](../components/support/fifo.c) 先进先出队列

## 4 操作系统

- 单片机采用硬实时操作系统 FreeRTOS (Real-Time Operating System)。确保系统能够在规定的时间内响应外部事件。
  - 在 [freertos.c](../Src/freertos.c) 中管理运行的任务。
